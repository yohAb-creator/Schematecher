{"chunk_id": "4.3.2-0", "text": "Introduction to TDA 4.3. Algorithms for Persistent Homology 4.3.2 Matrix Reduction Algorithm In practice, a different algorithm is used, the Matrix Reduction Algorithm. This algo- rithm implements the same intuition as the persistence pairing algorithm. It has a few advantages: First off, it is more efficient (it avoids the need to add the same boundaries multiple times, similarly to the version of the persistence pairing algorithm provided in [1]). Second, it is phrased in the language of matrices, which allows us to implement it more efficiently using matrix-multiplication techniques. Lastly, the way we describe it in the following it also works with non-simplex-wise filtrations. In the matrix reduction algorithm, we first find a total order on our simplices. If the input filtration is simplex-wise, this is just the insertion order. Otherwise, we order the simplices primarily by insertion order, and within each set of simultaneously added simplices, we order the simplices by increasing dimension, and then lexicographically. Then, we construct an N\u00d7N matrix, which is the so-called boundary matrix. Each row and column is labelled by a simplex, ordered by the order we defined above. We then insert a 1 at row \u03c3 and column \u03c4, if \u03c3 is part of the boundary of \u03c4. We now modify this boundary matrix to obtain the reduced boundary matrix, from which the persistence pairings can then be read off. We process the columns from left to right. For each column c, we look at the lowest 1 in the column. We call this 1 the pivot element of the column. If there is a column c\u2032 < c to the left that also has a pivot element in the same row, we add c\u2032 to c (in Z ). This is repeated until no such column 2 c\u2032 < c exists. Afterprocessingallthecolumns, thematrixisinareducedform: Foreveryrow, there is at most one column whose lowest 1 (its pivot element) lies in that row. From this we can now read the persistence pairings: Empty columns correspond to creators (births). To find the death of a creator, look at its corresponding row, and search for a column that has a pivot element in that row. This column is the destructor corresponding to the creator. If there is no such column, this creator never dies, i.e., is unpaired or paired with \u221e. We again summarize this algorithm in the pseudocode below. Let us now analyze at the runtime of this algorithm. For each column (O(N)), we might have to add O(N) times a column, and each addition takes O(N). So, by this very rough analysis we have a runtime of O(N3). But, since the reduction process is very similar to Gaussian elimination, we can actually perform the reduction using techniques that yield a runtime of O(N\u03c9), where \u03c9 is the matrix-multiplication exponent. However, in practice this is notveryusefulsinceefficientmatrix-multiplicationalgorithmsareverycomplexandhave large constants, while the naive implementation runs in essentially O(N) time anyways since the involved matrices are so sparse. Exercise 4.7. Consider the following simplicial complex, and the simplex-wise filtra- tion which first inserts the vertices in the order a,b,c,d,e, and the rest of the simplices as specified by the numbering in Figure 4.3. Execute both the persistence pairing algorithm and matrix reduction algorithm on this filtration. What are the similarities and differences in the algorithms? To 53 Chapter 4. Persistence Introduction to TDA Algorithm 2: The matrix reduction algorithm. Input: A filtration of K. Find an ordering \u03c3 ,...,\u03c3 corresponding to a simplex-wise filtration of K 1 N consistent with the given filtration; M := 0N\u00d7N; for 1 \u2a7d i,j \u2a7d N do if \u03c3 \u2208 \u03b4\u03c3 then i", "rank": 0, "metadata": {"section": "4.3.2"}}
{"chunk_id": "4.3.2-1", "text": "similarities and differences in the algorithms? To 53 Chapter 4. Persistence Introduction to TDA Algorithm 2: The matrix reduction algorithm. Input: A filtration of K. Find an ordering \u03c3 ,...,\u03c3 corresponding to a simplex-wise filtration of K 1 N consistent with the given filtration; M := 0N\u00d7N; for 1 \u2a7d i,j \u2a7d N do if \u03c3 \u2208 \u03b4\u03c3 then i j M := 1; ij end end for j = 1 to n do \u2113 := max({\u22121}\u222a{i | M = 1}); ij while \u2113 \u0338= \u22121 and \u2203j\u2032 < j such that \u2113 = max({\u22121}\u222a{i | M = 1}) do ij\u2032 M := M +M ; \u00b7j \u00b7j \u00b7j\u2032 \u2113 := max({\u22121}\u222a{i | M = 1}); ij end end for j = 1 to n do if M = 0N then \u00b7j Label \u03c3 a constructor; j for j\u2032 = 1 to n do if j = max({\u22121}\u222a{i | M = 1}) then ij\u2032 Pair \u03c3 to \u03c3 ; j j\u2032 Label \u03c3 a destructor; j\u2032 end end end end Pair all unpaired constructors with \u221e; 54 Introduction to TDA 4.3. Algorithms for Persistent Homology better see what happens, label the columns in the matrix by the sum of columns they currently represent. Represent the results you obtained by a persistence diagram, and also by the persistence barcodes. d 8 c 7 9 13 10 14 12 e 6 a 11 b Figure 4.3: The filtration for Exercise 4.7. Exercise 4.8. A Union-Find data structure is a data structure that maintains disjoint sets dynamically. Given a ground set X, such a data structure maintains a family S of disjoint subsets of X, where each subset is represented by the smallest element contained in it. It supports three operations: MakeSet(x) creates a new set {x}. FindSet(x) returns the representative (minimum) of the set in S which contains x (or \u201cno\u201d if x is not contained in any set). Union(x,y) merges the sets containing x and y into a single one. All of these operations can be implemented in amortized \u0398(\u03b1(n)) time, where \u03b1 is the extremely slowly growing inverse Ackermann function and can be considered a constant for any real world application. Consider a simplicial complex K with its vertices ordered v ,...,v , and consider 0 n its lower star filtration. Find an algorithm to compute the 0-dimensional persistence diagram (i.e., the persistence pairings) of K which makes use of a Union-Find data structure. How many Union-Find operations do you need to perform? Questions 13. What is a filtration? State the definition and describe different ways how filtra- tions appear in topology and data analysis. 14. What is persistent homology? State the formal definitions and give examples. 15. How can persistent homology be computed? Discuss the two algorithms de- scribed in Section 4.3. References [1] Tamal Krishna Dey and Yusu Wang, Computational topology for data analysis, Cambridge University Press, 2022. 55", "rank": 1, "metadata": {"section": "4.3.2"}}
