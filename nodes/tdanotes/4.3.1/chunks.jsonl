{"chunk_id": "4.3.1-0", "text": "Introduction to TDA 4.3. Algorithms for Persistent Homology Exercise 4.4. Consider the simplex-wise filtration induced by the order \u03c3 ,...,\u03c3 on 1 N the simplices of a complex K. When does the order \u03c3 ,...,\u03c3 ,\u03c3 ,\u03c3 ,\u03c3 ,...,\u03c3 1 k\u22121 k+1 k k+2 N induce a simplex-wise filtration too? When it does, describe the relation between the corresponding persistence diagrams. Exercise 4.5. Give two filtrations X \u2286 ... \u2286 X and Y \u2286 ... \u2286 Y that have the 1 n 1 n same persistence diagrams but for which for any i \u2208 {1,...,n}, X is not homotopy- i equivalent to Y . i 4.3 Algorithms for Persistent Homology So far we have considered homology and persistent homology only on a mathematical level. However, for practical applications we are interested in actually computing homo- logical information. In this section we discuss how we can compute persistence pairings given simplicial filtrations. This will of course also allow us to compute persistence diagrams and persistence barcodes. 4.3.1 Persistence Pairing Algorithm The first algorithm we consider is the so-called persistence pairing algorithm. It only works on simplex-wise filtrations, we thus restrict our attention to such filtrations. In any time step j, we add a single simplex \u03c3 := K \\K . Let p be its dimension. There j j j\u22121 are only two things that can happen to the homology when adding \u03c3 : Either, a new j non-boundary p-cycle c (i.e., a hole) is born, or a (p\u22121)-cycle becomes a boundary (i.e., a hole dies). In the first case we say that \u03c3 is a creator. Otherwise, we say that \u03c3 j j is a destructor. The fact that in every step exactly one of the two events happens is a consequence of the Euler characteristic, as discussed in Exercise 3.33. When a new simplex \u03c3 destroys a hole, this corresponds to an interval of the persis- j tence barcode ending. The beginning of that interval is at the time step when this hole was born, which corresponds to a unique simplex (recall, we are considering simplex-wise filtrations only). This unique simplex must be a creator, since when it was inserted a hole was born. The idea of the persistence pairing algorithm is to form pairings between destructors and creators. To do this, the algorithm assumes the newly added simplex \u03c3 j to be a destructor, and tries to find the corresponding unpaired creator using a simple heuristic. If no such creator can be found by the procedure, we know that \u03c3 must j actually be a creator itself. The heuristic is quite simple to describe. We have to look for an unpaired creator only within a cycle c that becomes a boundary due to the insertion of \u03c3 . Among this j cycle c, we wish to pair \u03c3 with the youngest unpaired creator. Any such cycle c must j be homologous to \u03b4\u03c3 , which is the simplest candidate for such a cycle c. This is thus j 51 Chapter 4. Persistence Introduction to TDA where the search begins. We first try to pair \u03c3 with the youngest (p\u22121)-simplex \u03c1 of j its boundary. If \u03c1 is unpaired, we pair it to \u03c3 and we are done. Otherwise, \u03c1 is already j paired with some (p-simplex) \u03c4. In this case we replace c by c+\u03b4\u03c4. This is now a new candidate cycle, in which we can try pairing \u03c3 to the youngest simplex. We repeat this j process until we found an unpaired creator we can pair \u03c3 to, or until we cannot continue j because c = 0.", "rank": 0, "metadata": {"section": "4.3.1"}}
{"chunk_id": "4.3.1-1", "text": "is already j paired with some (p-simplex) \u03c4. In this case we replace c by c+\u03b4\u03c4. This is now a new candidate cycle, in which we can try pairing \u03c3 to the youngest simplex. We repeat this j process until we found an unpaired creator we can pair \u03c3 to, or until we cannot continue j because c = 0. In this case we label \u03c3 as a new creator. At the end of the algorithm j (after processing all steps of the filtration), all remaining unpaired creators correspond to holes present at the last step of the filtration, and we pair them with the element \u221e. We refrain from giving a complete proof of this algorithm\u2019s correctness. Such a proof can be found in [1], however the algorithm presented there is slightly more complex and more efficient. We would only like to note that when we label a simplex a creator that this is correct to do so: If we reach c = 0 we know that the boundary of \u03c3 is homologous j to 0 (we obtained 0 by adding boundaries to \u03b4\u03c3 ). Thus, \u03c3 cannot be a destructor. We j j can thus safely label \u03c3 as a new creator. j We summarize this algorithm in the following pseudocode: Algorithm 1: The persistence pairing algorithm. Input: A simplex-wise filtration of K given by an order of simplices \u03c3 ,...,\u03c3 1 N for j = 1 to n do c := \u03b4\u03c3 ; j while c \u0338= 0 do i := largest integer such that \u03c3 \u2208 c and \u03c3 is creator; i i \u03c1 := \u03c3 ; i if \u03c1 is unpaired then Label \u03c3 as destructor and pair \u03c1 and \u03c3 ; j j c := 0 else \u03c4 := simplex \u03c1 is paired to; c := c+\u03b4\u03c4; end end if \u03c3 has not been labelled a destructor then j Label \u03c3 a constructor; j end end Pair all unpaired constructors with \u221e; Exercise4.6. Let G be a weighted connected graph, where all edge weights are pairwise distinct. Consider a filtration that first inserts all vertices (in some arbitrary order) and then inserts the edges one by one, ordered by increasing weight. What is the set of destructors? 52", "rank": 1, "metadata": {"section": "4.3.1"}}
