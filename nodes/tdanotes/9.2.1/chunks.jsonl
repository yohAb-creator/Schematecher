{"chunk_id": "9.2.1-0", "text": "Chapter 9. Multiparameter persistence Introduction to TDA We can now give two examples of filtrations indexed by P = R\u00d7Nop, each of which induces a P-persistence module via the observation above. The first one formalizes the discussion at the beginning of the chapter. The second one applies a similar idea to the \u010cech complex. Example 9.5. Let X be a finite metric space. Then the family (VRr d (X)) r\u2208R,d\u2208N defined above is a filtration indexed by R\u00d7Nop. It is called the degree-Rips bifiltration. Example 9.6. Let X \u2286 Rn be a finite point cloud. For r \u2208 R and d \u2208 N, define MCr = {x \u2208 Rn : |B(x,r)\u2229X| \u2a7e d} \u2286 Rn. d Note that, for d = 1, this is just the union-of-balls used to define the \u010cech complex. The family (MCr d (X)) r\u2208R,d\u2208N is a filtration (of topological spaces) indexed by R\u00d7Nop. It is called the multicover bifiltration. Both of the filtrations above can also be thought of as indexed over R2 (after a reparameterization). In general, we call an Rn-filtration (resp. Rn-persistence module) an n-parameter filtration (resp. n-parameter persistence module). For n \u2a7e 2, we also say \u2018multiparameter\u2019. For n = 2 the terms bifiltration and bipersistence module are common. 9.2 Representing persistence modules indexed by posets 9.2.1 Barcodes? Recall that a p.f.d. persistence module indexed by can be uniquely represented by U R a barcode. In Chapter 6, we saw that this follows from the fact that any such can be U decomposed into interval modules in a unique way: \u223c (cid:77) U = I . \u27e8a,b\u27e9 i\u2208I Each interval in this decomposition corresponds to a bar in the barcode of . We could U hope a similar statement holds for modules indexed by any poset P. The following definition and theorem should give us some hope: \u223c Definition 9.7. A persistence module U is called indecomposable if U = U \u2295U implies 1 2 that U = 0 or U = 0. 1 2 Exercise 9.8. Show that interval modules (indexed by R) are indecomposable. Theorem 9.9. Let U be a p.f.d. persistence module (indexed by a poset P). Then, there is a unique decomposition: \u223c (cid:77) U = U , i i\u2208I where each persistence module U is indecomposable. i 98 Introduction to TDA 9.2. Representing persistence modules indexed by posets Understanding P-persistence modules thus boils down to understanding indecompos- ables (indexed by P). For P = R , it turns out that indecomposables are precisely interval modules, leading to Theorem 6.36. However, for general P, the situation is much more complicated. Without going into details: It is not possible to parameterize indecompos- ables in terms of some nice family of subsets of P. The decomposition of Theorem 9.9 therefore does not lead to a workable notion of barcode in general. In fact, it is not possible to define any reasonable notion of a barcode for P-persistence modules, in the following sense. Definition 9.10. Let (P,\u2aaf) be a poset and let U be a P-persistence module. We say a multiset B of subsets of P is a reasonable barcode for U if rank(u ) = |{B \u2208 B : p,p\u2032 \u2208 B}| (\u2200p \u2aaf p\u2032). p,p\u2032 That is, the rank of the map u : U \u2192 U can be computed by counting the p,p\u2032 p p\u2032 number of \u2018bars\u2019 that contain both p and p\u2032. Exercise 9.11. Show that the usual barcode for a p.f.d. persistence module indexed by R is reasonable in the above sense. Exercise 9.12. For p \u2208 P, show that dim U is greater than", "rank": 0, "metadata": {"section": "9.2.1"}}
{"chunk_id": "9.2.1-1", "text": "of the map u : U \u2192 U can be computed by counting the p,p\u2032 p p\u2032 number of \u2018bars\u2019 that contain both p and p\u2032. Exercise 9.11. Show that the usual barcode for a p.f.d. persistence module indexed by R is reasonable in the above sense. Exercise 9.12. For p \u2208 P, show that dim U is greater than or equal to the number of p bars that contain p in a reasonable barcode for U. Example 9.13. Let P = {0,1,2}\u00d7{0,1,2} and consider the following persistence module indexed by P: F id F 0 f : a (cid:55)\u2192 (a,0) id g g : (a,b) (cid:55)\u2192 a U = F f F2 h F , where h : (a,b) (cid:55)\u2192 a+b j id j : a (cid:55)\u2192 (0,a) 0 F id F We claim U cannot have a reasonable barcode. To see this, suppose B is a reasonable barcode for U. Note that rank(h\u25e6f) = rank(g\u25e6f) = rank(h\u25e6j) = 1. By the reasonability assumption, there thus must be subsets I,J,K \u2208 B with (0,1),(2,1) \u2208 I, (0,1),(1,2) \u2208 J, (1,0),(2,1) \u2208 K. Since dim U = dim U = 1, we know by Exercise 9.12 that (0,1) and (2,1) occur 0,1 2,1 in at most one element of B. But that means that I = J, and I = K, and so in fact I = J = K \u2287 {(0,1),(2,1),(1,2)}. Thus, using reasonability again, we find that rank(g\u25e6j) \u2a7e 1, contradicting the fact that g\u25e6j = 0. 99", "rank": 1, "metadata": {"section": "9.2.1"}}
