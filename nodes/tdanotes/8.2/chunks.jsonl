{"chunk_id": "8.2-0", "text": "Introduction to TDA 8.2. Persistent Cycles Given an annotation, we can now clearly check linear independence of cycles by simply checking linear independence of a set of vectors, for which we have existing tools such as Gaussian elimination. Proposition 8.6. In every simplicial complex K and for every p \u2a7e 0, there exists an annotation of p-simplices, and such an annotation can also be computed. Proof. (Sketch for p = 1) We can compute a spanning forest T, and let m be the number of remaining edges. We initialize annotations of length m, and set a(e) = 0 for every edge in the spanning forest T. For every remaining edge e , we set a (e ) = 1 if and only i j i if j = i, and 0 otherwise. For every triangle t \u2208 K, if the annotation of its boundary \u03b4t is not 0, we find a non- zero entry b in a(\u03b4t) and add a(\u03b4t) to every edge with a (e) = 1, and we delete the u u u-th entry from all annotations. One can show that this yields a valid annotation, and it can be implemented in O(n3), and more clever implementations work in O(n\u03c9). To check independence of cycles in our set C more efficiently, we add auxiliary anno- tations also to vertices in a shortest path tree T rooted at v. We give v the annotation v 0, and for a vertex x that is the child of y, we set a(x) := a(y)+a(e ). For every cycle xy defined by the non-tree edge e = uw, we now have a(c ) = a(u)+a(w)+a(e). So, we e never actually have to compute an explicit representation of a cycle by its edges, we only need to store its weight, the shortest path trees with the auxiliary annotations, and the non-tree edge e. Note that the auxiliary annotations can be computed in O(gn) for the whole tree, thus in O(gn2) for all trees. Finally, we have to check independence. Given an (n\u00d7m) matrix M, we can find the lexicographic leftmost set of independent columns in time O(max(n,m)\u03c9). Instead of naively doing this n2 times (once for every cycle), we group our cycles of C into groups A of size g, and compute the leftmost set for [B|A ], and thus we get O(n2g\u03c9\u22121) runtime i i for this step. To summarize, computing C takes O(n2logn), sorting the O(n2) cycles also takes O(n2logn), and for checking linear independence we need O(n\u03c9) for the annotations of the edges, O(gn2) for the auxiliary annotations, and O(n2g\u03c9\u22121) for the block-wise linear independence checking. Overall, we thus get a runtime of O(n\u03c9 +n2g\u03c9\u22121). Theorem 8.7. Given a 2-dimensional simplicial complex K with n triangles and a weight function w on its edges, we can compute an optimal basis of H (K) in time 1 O(n\u03c9 +n2g\u03c9\u22121). 8.2 Persistent Cycles In the persistent setting, given a simplex-wise filtration F and an interval [b,d], can we find an optimal persistent p-cycle c that is born at b and dies at d? Sadly, this problem is already known to be NP-hard for d < \u221e and p \u2a7e 1. However, if we assume that K is a weak (p+1)-pseudomanifold, i.e., a simplicial complex in which 93 Chapter 8. Optimal Generators Introduction to TDA eachp-simplex isa face ofat most2 (p+1)-simplices, then there existsa polynomial-time algorithm, which we will describe in this section. If we consider cycles that live until \u221e, we can solve the problem in polynomial time for p = 1, but it is NP-hard for p \u2a7e 2. Here, the", "rank": 0, "metadata": {"section": "8.2"}}
{"chunk_id": "8.2-1", "text": "simplicial complex in which 93 Chapter 8. Optimal Generators Introduction to TDA eachp-simplex isa face ofat most2 (p+1)-simplices, then there existsa polynomial-time algorithm, which we will describe in this section. If we consider cycles that live until \u221e, we can solve the problem in polynomial time for p = 1, but it is NP-hard for p \u2a7e 2. Here, the assumption of K being a weak (p+1)- pseudomanifold does not save us. However, if we further assume that the complex can be embedded in Rp+1, then it is again polynomial. To solve the problem for d < \u221e in a weak (p + 1)-pseudomanifold, we consider undirected flow networks: We have a graph, where every edge has a capacity in [0,\u221e], some sources, and some sinks, and we want to find the maximum flow we can send from the sources to the sinks without sending too much flow through any edge. Recall that if we consider a cut which separates the sources from the sinks, the capacity of this cut is an upper bound on the value of the maximum flow. Furthermore, if we consider the minimum such cut, its capacity is equal to the value of the maximum flow. This can be solved in polynomial time. We can build a dual graph G, by placing a vertex into every (p + 1)-simplex and adding an edge whenever they share a p-simplex. We furthermore add a dummy vertex which gets connected to all vertices which only have one neighbor. We are going to make the vertex belonging to the (p+1)-simplex which is the destructor of our desired cycle the source. Furthermore, we make the dummy vertex as well as all vertices belonging to (p+1)-simplices added after the destructor into sinks. Edges added at or before the birth are getting the capacity equal to their weight, while all other edges get capacity \u221e. Then, it turns out that the p-simplices belonging to the edges in a minimum cut separating the sources from the sinks are an optimal persistent cycle. Exercise 8.8. Consider a simplex-wise filtration on a simplicial complex that is a weak (p + 1)-pseudomanifold, and consider some interval [b,d] (for d < \u221e) such that there exists a p-cycle born at b and dying at d. We look at the dual graph G with source and sinks defined as in the lecture. Consider a cut with finite capacity that separates the source from the sinks. Let c be the chain corresponding to the p-simplices dual to the edges going over this cut. Show that c is a p-cycle born at b and dying at d, and show that its weight is equal to the capacity of the cut. This exercise proves one direction of the correctness of the algorithm described above. The other direction is similar. We get the following result. Theorem 8.9. Given a a simplex-wise filtration on a simplicial complex that is a weak (p+1)-pseudomanifold and an interval [b,d] (for d < \u221e), we can compute an optimal p-cycle born at b and dying at d in polynomial time. For details, we refer to Chapter 5 in the book of Dey and Wang [1]. Questions 32. (Thistopicwasnotcoveredinthisyear\u2019scourseinFS25andthereforethefollowingquestion will not be asked in the exam.)How can we compute an optimal basis given a set of 94 Introduction to TDA 8.2. Persistent Cycles cycles that contain one? Explain the algorithm described in Section 8.1. Further, explain annotations and how they can be used to check linear independence. 33. (Thistopicwasnotcoveredinthisyear\u2019scourseinFS25andthereforethefollowingquestion willnotbeaskedintheexam.)How can we compute a set of 1-cycles that contain an optimal basis of H ? Describe the algorithm to", "rank": 1, "metadata": {"section": "8.2"}}
{"chunk_id": "8.2-2", "text": "an optimal basis given a set of 94 Introduction to TDA 8.2. Persistent Cycles cycles that contain one? Explain the algorithm described in Section 8.1. Further, explain annotations and how they can be used to check linear independence. 33. (Thistopicwasnotcoveredinthisyear\u2019scourseinFS25andthereforethefollowingquestion willnotbeaskedintheexam.)How can we compute a set of 1-cycles that contain an optimal basis of H ? Describe the algorithm to do this and prove its correctness. 1 34. (Thistopicwasnotcoveredinthisyear\u2019scourseinFS25andthereforethefollowingquestion will not be asked in the exam.)How can we compute an optimal persistent cycle? Explain the algorithm described in Section 8.2. References [1] Tamal Krishna Dey and Yusu Wang, Computational topology for data analysis, Cambridge University Press, 2022. 95", "rank": 2, "metadata": {"section": "8.2"}}
