{"chunk_id": "8.1-0", "text": "Chapter 8 Optimal Generators In some applications, we are not only interested in the number of holes in our data, but we also want to get representations of these holes in the data. In other words, we are interested in finding a \u201crepresentative\u201d basis of the homology group. There are two main challenges to picking such a basis: First off, there are many different choices of homology classes which form a basis of the homology group. Second off, even within a single homology class, there are many homologous cycles. Thus, there are many different choices for cycles as bases of the homology group. How do we find good bases? To specify our optimization target, we define a weight function w : (cid:80) K p \u2192 R\u2a7e0 on the p-simplices, and the weight of a chain is simply the sum, i.e., w(c) = \u03b1 w(\u03c3 ) for (cid:80) i i c = \u03b1 \u03c3 . The weight of a set of cycles C is then the sum of weights of each cycle. i i We are now interested in cycles that have minimal weight in their homology class, or at bases with minimum total weight. We look at this problem in two settings: first we look at the case where we are given a fixed simplicial complex and we want to find an optimal basis for the homology of this complex. This can be applied for example if the persistence diagram of a filtration gives us a range of values in which we expect the complex to nicely capture the shape of the data. We can then compute an optimal basis for the homology of the fixed complex for some value in this range. In some applications, we might also want to take a closer look at single intervals in the persistence barcode, that is, understand a hole that is born at time b and dies at time d (for example, to decide whether it corresponds to a feature in the data or is just a consequence of the process). This brings us to the second setting we look at in this chapter, where we want to find an optimal representative of a persistent homology class. 8.1 Optimal Basis of a Fixed Complex Definition 8.1. A set C of cycles is an optimal basis for H (K) if it is a basis and there p is no other basis C\u2032 with w(C\u2032) < w(C). How can we compute such an optimal basis? 90 Introduction to TDA 8.1. Optimal Basis of a Fixed Complex In a first step, we are going to compute a set of cycles C which contains an optimal basis. Then, we perform a greedy algorithm to find the optimal basis in a similar way to Kruskal\u2019s algorithm for Minimum Spanning Tree: we sort the cycles by increasing weight, and start our basis B with the trivial cycle 0. Then, we simply iterate through our cycles and add a cycle c to our basis if it cannot be written as a linear combination i of our current basis. Finally, we remove 0 again from B. The correctness of this greedy approach, as well as the correctness of many other greedy algorithms including the above-mentioned Kruskal, follows from a more general framework in matroid theory. Exercise 8.2. A matroid is a collection I of subsets of some universe U, such that 1. \u2205 \u2208 I, and if some set L is in I, all L\u2032 \u2286 L are also in I. 2. If some L,L\u2032 are in I, and |L\u2032| = |L|+1, then there exists an element f \u2208 L\u2032\\L,", "rank": 0, "metadata": {"section": "8.1"}}
{"chunk_id": "8.1-1", "text": "general framework in matroid theory. Exercise 8.2. A matroid is a collection I of subsets of some universe U, such that 1. \u2205 \u2208 I, and if some set L is in I, all L\u2032 \u2286 L are also in I. 2. If some L,L\u2032 are in I, and |L\u2032| = |L|+1, then there exists an element f \u2208 L\u2032\\L, such that L\u222a{f} \u2208 I. The sets in I are also called the independent sets of the matroid. The inclusion- maximal sets in I are called bases. (a) Show that for U being any finite set of vectors in some vector space, the family I of subsets of U corresponding to linearly independent vectors forms the family of independent sets of a matroid. (b) Show that for any graph G = (V,E), the family I of subsets of E corresponding to forests in G forms the family of independent sets of a matroid. (c) Consider a matroid on a universe U with a weight function w : U \u2192 R. Consider the following greedy algorithm: begin with L = \u2205, and consecutively add the lowest-weight element e \u0338\u2208 L such that L\u222a{e} remains an independent set, until reaching a basis. Show that this greedy algorithm finds a minimum- weight basis. We now need to show that we can implement all of the pieces of the algorithm we outlined above. For the first step, we need to be able to compute our set C. For the second greedy step, we need to be able to check linear independence of a set of cycles. SincetheproblemofcomputinganoptimalbasisisNP-hardforp > 1, wewillfocuson computing a basis for H (K). Without loss of generality, we say that K is 2-dimensional, 1 with n triangles and O(n) edges and vertices. To compute C, we begin with C = \u2205. For all vertices v, we compute the shortest path tree T rooted at v. We can do this for example with Dijkstra\u2019s algorithm. For every v edge e that is not in T , we add the unique simple cycle in T \u222a {e} to C. This can be v v implemented in O(n2logn), and yields a set of cycles with |C| \u2208 O(n2). But, we need to prove that it is indeed a set which contains an optimal basis. Lemma 8.3. C as computed by the method above contains an optimal basis. 91 Chapter 8. Optimal Generators Introduction to TDA Proof. Let C\u2217 be an optimal basis. Towards a contradiction, let c be a cycle contained in C\u2217\\C. Since we consider Z -homology, c is a simple cycle, i.e., no edge is used multiple 2 times.1 Let v be a vertex in c, and let T be the corresponding shortest path tree. There v must be an edge e = {u,w} in c\\T , since T is a tree. Let \u03a0 and \u03a0 be the shortest v v v,u v,w paths from v to u and w, respectively. These paths must be contained in T . Let us v similarly consider \u03a0\u2032 and \u03a0\u2032 to be the paths from v to u,w in c which do not use v,u v,w the edge e. If we now had \u03a0\u2032 = \u03a0 and \u03a0\u2032 = \u03a0 , c would be the unique simple v,u v,u v,w v,w cycle in T \u222a{e} and thus c would be in C. However, since we assumed this not to be the v case, w.l.o.g. we can assume that \u03a0\u2032 \u0338= \u03a0 . v,u v,u We now define the cycles c = \u03a0\u2032 + {e} + \u03a0 and c = \u03a0 + \u03a0\u2032 . We can", "rank": 1, "metadata": {"section": "8.1"}}
{"chunk_id": "8.1-2", "text": "unique simple v,u v,u v,w v,w cycle in T \u222a{e} and thus c would be in C. However, since we assumed this not to be the v case, w.l.o.g. we can assume that \u03a0\u2032 \u0338= \u03a0 . v,u v,u We now define the cycles c = \u03a0\u2032 + {e} + \u03a0 and c = \u03a0 + \u03a0\u2032 . We can 1 v,w v,u 2 v,u v,u now see that as we work in Z , c +c = \u03a0\u2032 +{e}+\u03a0\u2032 = c. Furthermore, we have 2 1 2 v,u v,w w(c ) \u2a7d w(c), since \u03a0 is a shortest path (in K), while \u03a0\u2032 is not necessarily shortest. 1 v,u v,u The same also holds for c : w(c ) \u2a7d w(c) since {\u03a0\u2032 ,e} can not be shorter than \u03a0 . 2 2 v,w v,u Let us now consider the homology classes of c and c . If both [c ] and [c ] were 1 2 1 2 dependent on C\u2217 \\ {c}, then so would [c], since c = c + c . Then, C\u2217 would not be a 1 2 basis. Thus, at least one of [c ] and [c ] has to be independent of C\u2217\\{c}. Let us consider 1 2 first that c is independent. Then, we could replace c by c in C\u2217 and get a basis which 1 1 is at least as good as C\u2217. If c is independent, we replace c by c in C\u2217. After replacing, 2 2 we use the same argument again on the new cycle. If we replaced c by c , we repeat 1 the argument with v\u2032, the common ancestor of \u03a0 and \u03a0\u2032 and the same edge e. If v,u v,w we replaced c by c , we repeat the argument with v\u2032 the common ancestor of \u03a0 ,\u03a0\u2032 2 v,u v,u and e an edge incident to u. By doing this we have made some \u201cprogress\u201d: In the second iteration of the argument, one of the two paths \u03a0\u2032 must have become equal to \u03a0. After doing the argument twice, we must have replaced c by a cycle c\u2032 that has w(c\u2032) \u2a7d w(c) and c\u2032 is actually in our set C. At the end, we thus get a basis C\u2032 with w(C\u2032) \u2a7d w(C\u2217) with C\u2032 \u2286 C. Therefore C contains an optimal basis. Exercise 8.4. Given a 2-dimensional simplicial complex K in which every pair of vertices u,v has a unique shortest path between them, show that the set C computed by the algorithm will contain all optimal bases of H (K). 1 So, we have finished the first step of our algorithm. It remains to figure out how to check independence. For this, we introduce annotations. Definition 8.5. An annotation of p-simplices is a function a : Kp \u2192 Zg giving each p- 2 simplex a binary vector of size g. This extends to chains by sums. An annotation must fulfill: \u2022 g = \u03b2 (K) p \u2022 a(z ) = a(z ) iff [z ] = [z ]. 1 2 1 2 1In general this would also follow from the weights being non-negative and C\u2217 being optimal. 92", "rank": 2, "metadata": {"section": "8.1"}}
